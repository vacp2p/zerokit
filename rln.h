/*! \file */
/*******************************************
 *                                         *
 *  File auto-generated by `::safer_ffi`.  *
 *                                         *
 *  Do not manually edit this file.        *
 *                                         *
 *******************************************/

#ifndef __RUST_RLN__
#define __RUST_RLN__
#ifdef __cplusplus
extern "C" {
#endif

/** <No documentation available> */
typedef struct CFr CFr_t;

/** <No documentation available> */
void
cfr_debug (
    CFr_t const * cfr);

/** <No documentation available> */
void
cfr_free (
    CFr_t * cfr);

/** <No documentation available> */
CFr_t *
cfr_zero (void);

/** <No documentation available> */
typedef struct FFI2_RLN FFI2_RLN_t;


#include <stddef.h>
#include <stdint.h>

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_CFr {
    /** <No documentation available> */
    CFr_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_CFr_t;

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_size {
    /** <No documentation available> */
    size_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_size_t;


#include <stdbool.h>

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_uint8 {
    /** <No documentation available> */
    uint8_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_uint8_t;

/** <No documentation available> */
typedef struct CResult_bool_ptr_Vec_uint8 {
    /** <No documentation available> */
    bool * ok;

    /** <No documentation available> */
    Vec_uint8_t err;
} CResult_bool_ptr_Vec_uint8_t;

/** <No documentation available> */
CResult_bool_ptr_Vec_uint8_t
ffi2_atomic_operation (
    FFI2_RLN_t * * rln,
    size_t index,
    Vec_CFr_t leaves,
    Vec_size_t indices);

/** <No documentation available> */
CResult_bool_ptr_Vec_uint8_t
ffi2_delete_leaf (
    FFI2_RLN_t * * rln,
    size_t index);

/** <No documentation available> */
Vec_CFr_t
ffi2_extended_key_gen (void);

/** <No documentation available> */
CResult_bool_ptr_Vec_uint8_t
ffi2_flush (
    FFI2_RLN_t * * rln);

/** \brief
 *  [`Box`][`rust::Box`]`<[T]>` (fat pointer to a slice),
 *  but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_boxed_uint8 {
    /** \brief
     *  Pointer to the first element (if any).
     */
    uint8_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_boxed_uint8_t;

/** <No documentation available> */
typedef struct FFI2_RLNWitnessInput {
    /** <No documentation available> */
    CFr_t * identity_secret;

    /** <No documentation available> */
    CFr_t * user_message_limit;

    /** <No documentation available> */
    CFr_t * message_id;

    /** <No documentation available> */
    Vec_CFr_t path_elements;

    /** <No documentation available> */
    slice_boxed_uint8_t identity_path_index;

    /** <No documentation available> */
    CFr_t * x;

    /** <No documentation available> */
    CFr_t * external_nullifier;
} FFI2_RLNWitnessInput_t;

/** <No documentation available> */
typedef struct FFI2_RLNProof FFI2_RLNProof_t;

/** <No documentation available> */
typedef struct CResult_FFI2_RLNProof_ptr_Vec_uint8 {
    /** <No documentation available> */
    FFI2_RLNProof_t * ok;

    /** <No documentation available> */
    Vec_uint8_t err;
} CResult_FFI2_RLNProof_ptr_Vec_uint8_t;

/** <No documentation available> */
CResult_FFI2_RLNProof_ptr_Vec_uint8_t
ffi2_generate_rln_proof (
    FFI2_RLN_t * const * rln,
    FFI2_RLNWitnessInput_t * const * witness_input);

/** <No documentation available> */
CResult_FFI2_RLNProof_ptr_Vec_uint8_t
ffi2_generate_rln_proof_with_witness (
    FFI2_RLN_t * const * rln,
    FFI2_RLNWitnessInput_t * const * witness_input);

/** <No documentation available> */
typedef struct CResult_CFr_ptr_Vec_uint8 {
    /** <No documentation available> */
    CFr_t * ok;

    /** <No documentation available> */
    Vec_uint8_t err;
} CResult_CFr_ptr_Vec_uint8_t;

/** <No documentation available> */
CResult_CFr_ptr_Vec_uint8_t
ffi2_get_leaf (
    FFI2_RLN_t * const * rln,
    size_t index);

/** <No documentation available> */
typedef struct CResult_slice_boxed_uint8_Vec_uint8 {
    /** <No documentation available> */
    slice_boxed_uint8_t ok;

    /** <No documentation available> */
    Vec_uint8_t err;
} CResult_slice_boxed_uint8_Vec_uint8_t;

/** <No documentation available> */
CResult_slice_boxed_uint8_Vec_uint8_t
ffi2_get_metadata (
    FFI2_RLN_t * const * rln);

/** <No documentation available> */
typedef struct FFI2_MerkleProof {
    /** <No documentation available> */
    Vec_CFr_t path_elements;

    /** <No documentation available> */
    Vec_uint8_t path_index;
} FFI2_MerkleProof_t;

/** <No documentation available> */
typedef struct CResult_FFI2_MerkleProof_ptr_Vec_uint8 {
    /** <No documentation available> */
    FFI2_MerkleProof_t * ok;

    /** <No documentation available> */
    Vec_uint8_t err;
} CResult_FFI2_MerkleProof_ptr_Vec_uint8_t;

/** <No documentation available> */
CResult_FFI2_MerkleProof_ptr_Vec_uint8_t
ffi2_get_proof (
    FFI2_RLN_t * const * rln,
    size_t index);

/** <No documentation available> */
CFr_t *
ffi2_get_root (
    FFI2_RLN_t * const * rln);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_uint8 {
    /** \brief
     *  Pointer to the first element (if any).
     */
    uint8_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_uint8_t;

/** \brief
 *  ////////////////////////////////////////////////////////
 */
CFr_t *
ffi2_hash (
    slice_ref_uint8_t input);

/** <No documentation available> */
CResult_bool_ptr_Vec_uint8_t
ffi2_init_tree_with_leaves (
    FFI2_RLN_t * * rln,
    Vec_CFr_t leaves);

/** <No documentation available> */
Vec_CFr_t
ffi2_key_gen (void);

/** <No documentation available> */
size_t
ffi2_leaves_set (
    FFI2_RLN_t * const * rln);

/** <No documentation available> */
void
ffi2_merkle_proof_free (
    FFI2_MerkleProof_t * proof);

/** <No documentation available> */
typedef struct CResult_FFI2_RLN_ptr_Vec_uint8 {
    /** <No documentation available> */
    FFI2_RLN_t * ok;

    /** <No documentation available> */
    Vec_uint8_t err;
} CResult_FFI2_RLN_ptr_Vec_uint8_t;

/** <No documentation available> */
CResult_FFI2_RLN_ptr_Vec_uint8_t
ffi2_new (
    size_t tree_depth,
    char const * config);

/** <No documentation available> */
CResult_FFI2_RLN_ptr_Vec_uint8_t
ffi2_new_with_params (
    size_t tree_depth,
    slice_ref_uint8_t zkey_buffer,
    slice_ref_uint8_t graph_data,
    char const * config);

/** <No documentation available> */
CFr_t *
ffi2_poseidon_hash (
    Vec_CFr_t inputs);

/** <No documentation available> */
CResult_FFI2_RLNProof_ptr_Vec_uint8_t
ffi2_prove (
    FFI2_RLN_t * const * rln,
    FFI2_RLNWitnessInput_t * const * witness_input);

/** <No documentation available> */
CResult_CFr_ptr_Vec_uint8_t
ffi2_recover_id_secret (
    FFI2_RLNProof_t * const * proof_1,
    FFI2_RLNProof_t * const * proof_2);

/** <No documentation available> */
void
ffi2_rln_free (
    FFI2_RLN_t * rln);

/** <No documentation available> */
void
ffi2_rln_proof_free (
    FFI2_RLNProof_t * rln);

/** <No documentation available> */
Vec_CFr_t
ffi2_seeded_extended_key_gen (
    slice_ref_uint8_t seed);

/** <No documentation available> */
Vec_CFr_t
ffi2_seeded_key_gen (
    slice_ref_uint8_t seed);

/** <No documentation available> */
CResult_bool_ptr_Vec_uint8_t
ffi2_seq_atomic_operation (
    FFI2_RLN_t * * rln,
    Vec_CFr_t leaves,
    Vec_uint8_t indices);

/** <No documentation available> */
CResult_bool_ptr_Vec_uint8_t
ffi2_set_leaf (
    FFI2_RLN_t * * rln,
    size_t index,
    CFr_t * const * value);

/** <No documentation available> */
CResult_bool_ptr_Vec_uint8_t
ffi2_set_leaves_from (
    FFI2_RLN_t * * rln,
    size_t index,
    Vec_CFr_t leaves);

/** <No documentation available> */
CResult_bool_ptr_Vec_uint8_t
ffi2_set_metadata (
    FFI2_RLN_t * * rln,
    slice_ref_uint8_t metadata);

/** <No documentation available> */
CResult_bool_ptr_Vec_uint8_t
ffi2_set_next_leaf (
    FFI2_RLN_t * * rln,
    CFr_t * const * value);

/** <No documentation available> */
CResult_bool_ptr_Vec_uint8_t
ffi2_set_tree (
    FFI2_RLN_t * * rln,
    size_t tree_depth);

/** <No documentation available> */
CResult_bool_ptr_Vec_uint8_t
ffi2_verify (
    FFI2_RLN_t * const * rln,
    FFI2_RLNProof_t * const * proof);

/** <No documentation available> */
CResult_bool_ptr_Vec_uint8_t
ffi2_verify_rln_proof (
    FFI2_RLN_t * const * rln,
    FFI2_RLNProof_t * const * proof);

/** <No documentation available> */
CResult_bool_ptr_Vec_uint8_t
ffi2_verify_with_roots (
    FFI2_RLN_t * const * rln,
    FFI2_RLNProof_t * const * proof,
    Vec_CFr_t roots);

/** <No documentation available> */
void
vec_cfr_free (
    Vec_CFr_t v);

/** <No documentation available> */
CFr_t const *
vec_cfr_get (
    Vec_CFr_t const * v,
    size_t i);


#ifdef __cplusplus
} /* extern \"C\" */
#endif

#endif /* __RUST_RLN__ */
