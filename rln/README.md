# Zerokit RLN Module

[![Crates.io](https://img.shields.io/crates/v/rln.svg)](https://crates.io/crates/rln)
[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](https://opensource.org/licenses/MIT)
[![License: Apache 2.0](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)

The Zerokit RLN Module provides a Rust implementation for working with
Rate-Limiting Nullifier [RLN](https://rfc.vac.dev/vac/raw/rln-v2) zkSNARK proofs and primitives.
This module allows you to:

- Generate and verify RLN proofs
- Work with Merkle trees for commitment storage
- Implement rate-limiting mechanisms for distributed systems

## Quick Start

> [!IMPORTANT]
> Version 0.7.0 is the only version that does not support WASM and x32 architecture.
> WASM support is available in version 0.8.0 and above.

### Add RLN as dependency

We start by adding zerokit RLN to our `Cargo.toml`

```toml
[dependencies]
rln = { git = "https://github.com/vacp2p/zerokit" }
```

## Basic Usage Example

The RLN object constructor requires the following files:

- `rln_final.arkzkey`: The proving key in arkzkey format.
- `graph.bin`: The graph file built for the input tree size

Additionally, `rln.wasm` is used for testing in the rln-wasm module.

In the following we will use [cursors](https://doc.rust-lang.org/std/io/struct.Cursor.html)
as readers/writers for interfacing with RLN public APIs.

```rust
use rln::{
    circuit::Fr,
    hashers::{hash_to_field_le, poseidon_hash},
    protocol::{keygen, RLNWitnessInput},
    public::RLN,
};

fn main() {
    // 1. Initialize RLN with parameters:
    // - the tree depth;
    // - the tree config, if it is not defined, the default value will be set
    let tree_depth = 20;
    let mut rln = RLN::new(tree_depth, "").unwrap();

    // 2. Generate an identity keypair
    let (identity_secret, id_commitment) = keygen();

    // 3. Add a rate commitment to the Merkle tree
    let leaf_index = 10;
    let user_message_limit = Fr::from(10);
    let rate_commitment = poseidon_hash(&[id_commitment, user_message_limit]);
    rln.set_leaf(leaf_index, rate_commitment).unwrap();

    // 4. Get the Merkle proof for the added commitment
    let (path_elements, identity_path_index) = rln.get_proof(leaf_index).unwrap();

    // 5. Set up external nullifier (epoch + app identifier)
    // We generate epoch from a date seed and we ensure is
    // mapped to a field element by hashing-to-field its content
    let epoch = hash_to_field_le(b"Today at noon, this year");
    // We generate rln_identifier from a date seed and we ensure is
    // mapped to a field element by hashing-to-field its content
    let rln_identifier = hash_to_field_le(b"test-rln-identifier");
    // We generate a external nullifier
    let external_nullifier = poseidon_hash(&[epoch, rln_identifier]);
    // We choose a message_id satisfy 0 <= message_id < user_message_limit
    let message_id = Fr::from(1);

    // 6. Generate and verify a proof for a message
    let signal = b"RLN is awesome";

    // 7. Compute x from the signal
    let x = hash_to_field_le(signal);

    // 8. Create witness input for RLN proof generation
    let witness = RLNWitnessInput::new(
        identity_secret,
        user_message_limit,
        message_id,
        path_elements,
        identity_path_index,
        x,
        external_nullifier,
    )
    .unwrap();

    // 9. Generate a RLN proof
    // We generate a RLN proof and proof values from the witness
    let (proof, proof_values) = rln.generate_rln_proof(&witness).unwrap();

    // 10. Verify a RLN proof
    // We verify the zk-proof against the provided proof and proof values
    let verified = rln.verify_rln_proof(&proof, &proof_values, &x).unwrap();
    // We ensure the proof is valid
    assert!(verified);
}
```

### Comments for the code above for point 5

The `external nullifier` includes two parameters.

The first one is `epoch` and it's used to identify messages received in a certain time frame.
It usually corresponds to the current UNIX time but can also be set to a random value or generated by a seed,
provided that it corresponds to a field element.

The second one is `rln_identifier` and it's used to prevent a RLN ZK proof generated
for one application to be re-used in another one.

### Features

- **Stateless Mode**: Allows the use of RLN without maintaining state of the Merkle tree.
- **Pre-compiled Circuits**: Ready-to-use circuits with Merkle tree depth of 20
- **Wasm Support**: WebAssembly bindings via rln-wasm crate with features like:
  - Browser and Node.js compatibility
  - Optional parallel feature support using [wasm-bindgen-rayon](https://github.com/RReverser/wasm-bindgen-rayon)
  - Headless browser testing capabilities
- **Merkle Tree Implementations**: Multiple tree variants optimized for different use cases:
  - **Full Merkle Tree**: Fastest access with complete pre-allocated tree in memory. Best for frequent random access (enable with `fullmerkletree` feature).
  - **Optimal Merkle Tree**: Memory-efficient sparse storage using HashMap. Ideal for partially populated trees (enable with `optimalmerkletree` feature).
  - **Persistent Merkle Tree**: Disk-based storage with [sled](https://github.com/spacejam/sled) for persistence across application restarts and large datasets (enable with `pmtree-ft` feature).

## Building and Testing

### Prerequisites

```sh
git clone https://github.com/vacp2p/zerokit.git
make installdeps
cd zerokit/rln
```

### Build Commands

```sh
# Build with default features
cargo make build

# Test with default features
cargo make test

# Test with stateless features
cargo make test_stateless
```

## Advanced: Custom Circuit Compilation

The `rln` (<https://github.com/rate-limiting-nullifier/circom-rln>) repository,
which contains the RLN circuit implementation used for pre-compiled RLN circuit for zerokit RLN.
If you want to compile your own RLN circuit, you can follow the instructions below.

### 1. Compile ZK Circuits for getting the zkey file

This script actually generates not only the zkey file for the RLN circuit,
but also the execution wasm file used for witness calculation.
However, the wasm file is not needed for the `rln` module,
because current implementation uses the iden3 graph file for witness calculation.
This graph file is generated by the `circom-witnesscalc` tool in [step 2](#2-generate-witness-calculation-graph).

To customize the circuit parameters, modify `circom-rln/circuits/rln.circom`:

```circom
pragma circom 2.1.0;
include "./rln.circom";
component main { public [x, externalNullifier] } = RLN(N, M);
```

Where:

- `N`: Merkle tree depth, determining the maximum membership capacity (2^N members).

- `M`: Bit size for range checks, setting an upper bound for the number of messages per epoch (2^M messages).

> [!NOTE]
> However, if `N` is too big, this might require a larger Powers of Tau ceremony
> than the one hardcoded in `./scripts/build-circuits.sh`, which is `2^14`.
> In such case, we refer to the official
> [Circom documentation](https://docs.circom.io/getting-started/proving-circuits/#powers-of-tau)
> for instructions on how to run an appropriate Powers of Tau ceremony and Phase 2 in order to compile the desired circuit. \
> Additionally, while `M` sets an upper bound on the number of messages per epoch (`2^M`),
> you can configure lower message limit for your use case, as long as it satisfies `user_message_limit ≤ 2^M`. \
> Currently, the `rln` module comes with a [pre-compiled](https://github.com/vacp2p/zerokit/tree/master/rln/resources)
> RLN circuit with a Merkle tree of depth `20` and a bit size of `16`,
> allowing up to `2^20` registered members and a `2^16` message limit per epoch.

#### Install circom compiler

You can follow the instructions below or refer to the
[installing Circom](https://docs.circom.io/getting-started/installation/#installing-circom) guide for more details.
Make sure to use the specific version `v2.1.0`.

```sh
# Clone the circom repository
git clone https://github.com/iden3/circom.git

# Checkout the specific version
cd circom && git checkout v2.1.0

# Build the circom compiler
cargo build --release

# Install the circom binary globally
cargo install --path circom

# Check the circom version to ensure it's v2.1.0
circom --version
```

#### Generate the zkey and verification key files example

```sh
# Clone the circom-rln repository
git clone https://github.com/rate-limiting-nullifier/circom-rln

# Install dependencies
cd circom-rln && npm install

# Build circuits
./scripts/build-circuits.sh rln

# Use the generated zkey file in subsequent steps
cp zkeyFiles/rln/final.zkey <path_to_rln_final.zkey>
```

### 2. Generate Witness Calculation Graph

The execution graph file used for witness calculation can be compiled following instructions
in the [circom-witnesscalc](https://github.com/iden3/circom-witnesscalc) repository.
As mentioned in step 1, we should use `rln.circom` file from `circom-rln` repository.

```sh
# Clone the circom-witnesscalc repository
git clone https://github.com/iden3/circom-witnesscalc

# Load the submodules
cd circom-witnesscalc && git submodule update --init --recursive

# Build the circom-witnesscalc tool
cargo build

# Generate the witness calculation graph
cargo run --package circom_witnesscalc --bin build-circuit ../circom-rln/circuits/rln.circom <path_to_graph.bin>
```

The `rln` module comes with [pre-compiled](https://github.com/vacp2p/zerokit/tree/master/rln/resources)
execution graph files for the RLN circuit.

### 3. Generate Arkzkey Representation for zkey file

For faster loading, compile the zkey file into the arkzkey format using
[ark-zkey](https://github.com/seemenkina/ark-zkey).
This is fork of the [original](https://github.com/zkmopro/ark-zkey) repository with the uncompressed arkzkey support.

```sh
# Clone the ark-zkey repository
git clone https://github.com/seemenkina/ark-zkey.git

# Build the ark-zkey tool
cd ark-zkey && cargo build

# Generate the arkzkey representation for the zkey file
cargo run --bin arkzkey-util <path_to_rln_final.zkey>
```

This will generate the `rln_final.arkzkey` file, which is used by the `rln` module.

Currently, the `rln` module comes with
[pre-compiled](https://github.com/vacp2p/zerokit/tree/master/rln/resources) arkzkey keys for the RLN circuit.

> [!NOTE]
> You can use this [convert_zkey.sh](./convert_zkey.sh) script
> to automate the process of generating the arkzkey file from any zkey file

Run the script as follows:

```sh
chmod +x ./convert_zkey.sh
./convert_zkey.sh <path_to_rln_final.zkey>
```

## FFI Interface

RLN provides C-compatible bindings for integration with C, C++, Nim, and other languages through [safer_ffi](https://getditto.github.io/safer_ffi/).

The FFI layer is organized into several modules:

- [`ffi_rln.rs`](./src/ffi/ffi_rln.rs) – Implements core RLN functionality, including initialization functions, proof generation, and proof verification.
- [`ffi_tree.rs`](./src/ffi/ffi_tree.rs) – Provides all tree-related operations and helper functions for Merkle tree management.
- [`ffi_utils.rs`](./src/ffi/ffi_utils.rs) – Contains all utility functions and structure definitions used across the FFI layer.

### Examples

Working examples demonstrating proof generation, proof verification and slashing in C and Nim:

- [C example](./ffi_c_examples/main.c) and [README](./ffi_c_examples/Readme.md)
- [Nim example](./ffi_nim_examples/main.nim) and [README](./ffi_nim_examples/Readme.md)

### Memory Management

- All **heap-allocated** objects returned from Rust FFI **must** be freed using their corresponding FFI `_free` functions.

## Getting Involved

Zerokit RLN public and FFI APIs allow interaction with many more features than what briefly showcased above.

We invite you to check our API documentation by running

```bash
cargo doc --no-deps
```

and look at unit tests to have an hint on how to interface and use them.

- Check the [unit tests](https://github.com/vacp2p/zerokit/tree/master/rln/tests) for more usage examples
- [RFC specification](https://rfc.vac.dev/vac/raw/rln-v2) for the Rate-Limiting Nullifier protocol
- [GitHub repository](https://github.com/vacp2p/zerokit) for the latest updates

## Detailed Protocol Flow

1. **Identity Creation**: Generate a secret key and commitment
2. **Rate Commitment**: Add commitment to a Merkle tree
3. **External Nullifier Setup**: Combine epoch and application identifier
4. **Proof Generation**: Create a zkSNARK proof that:
   - Proves membership in the Merkle tree
   - Ensures rate-limiting constraints are satisfied
   - Generates a nullifier to prevent double-usage
5. **Proof Verification**: Verify the proof without revealing the prover's identity
6. **Slashing Mechanism**: Detect and penalize double-usage attempts
